<html>
<head><title>CRYSTAL</title></head>
<body>
<h1>CRYSTAL</h1><p><br />
Gaussian implements the methods of quantum chemistry: the Hartree–Fock (HF), some post-Hartree–Fock methods, density functional theory (DFT), molecular mechanics and semi-empirical quantum chemistry methods.
</p><p>Gaussian
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#web_site"><span class="tocnumber">1</span> <span class="toctext">web site</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Overview"><span class="tocnumber">2</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#How_to_use_it_on_PCT_laboratory_cluster_resources_.3F"><span class="tocnumber">3</span> <span class="toctext">How to use it on PCT laboratory cluster resources &#160;?</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#SGE_example_script"><span class="tocnumber">4</span> <span class="toctext">SGE example script</span></a></li>
</ul>
</div>

<h1><span class="mw-headline" id="web_site">web site</span></h1>
<p><a target="_blank" rel="nofollow noreferrer noopener" class="external free" href="http://www.crystal.unito.it/index.php">http://www.crystal.unito.it/index.php</a>
</p>
<h1><span class="mw-headline" id="Overview">Overview</span></h1>
<p>CRYSTAL is a general-purpose program for the study of crystalline solids, and the first which has been distributed publicly. The first version was released in 1988 and then six next versions have followed: CRYSTAL92, CRYSTAL95, CRYSTAL98, CRYSTAL03, CRYSTAL06 and CRYSTAL09.
</p><p>The CRYSTAL program computes the electronic structure of periodic systems within Hartree Fock, density functional or various hybrid approximations (global, range-separated and double-hybrids). The Bloch functions of the periodic systems are expanded as linear combinations of atom centred Gaussian functions. Powerful screening techniques are used to exploit real space locality.
Restricted (Closed Shell) and Unrestricted (Spin-polarized) calculations can be performed with all-electron and valence-only basis sets with effective core pseudo-potentials.
</p><p>The program can automatically handle space symmetry (230 space groups, 80 two-sided plane groups, 99 rod groups, 45 point groups are available ). Point symmetries compatible with translation symmetry are provided for molecules. Helical symmetry is now available (up to order 48).
Input tools allow the generation of a slab (2D system), or a cluster (0D system), from a 3D crystalline structure, or the creation of a supercell with a defect, or nanotubes (1D system) from a single-layer slab model (2D system).
</p><p>The code may be used to perform consistent studies of the physical and chemical properties of molecules, polymers, nanotubes, surfaces and crystalline solids:
</p>
<pre>   Structural features
   Vibrational properties
       More information can be found at the following link
       Examples of graphical animations of vibrational modes are shown here
   Electronic structure
   Magnetic properties
   Dielectric properties (linear and non-linear electric susceptibilities up to forth-order)
   Elastic, piezoelectric and photoelastic properties
</pre>
<p><br />
</p>
<h1><span class="mw-headline" id="How_to_use_it_on_PCT_laboratory_cluster_resources_.3F">How to use it on PCT laboratory cluster resources &#160;?</span></h1>
<p>module load crystal/14-1.0.4-1.x86_64/std
</p><p><br />
</p>
<h1><span class="mw-headline" id="SGE_example_script">SGE example script</span></h1>
<pre style="white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word;"> 
#!/bin/bash
#
#$ -S /bin/bash
#$ -cwd
#
#$ -q lisboa@lisboa16
#$ -pe parallel 12
#$ -N d032
#$ -j y
#$ -o sge2.out
#$ -e sge2.out
#$ -V
#$ -v MODULEPATH

set -x

. /etc/profile.d/z00_lmod.sh
module load compiler/intel/std
module load crystal/14-1.0.4-1.x86_64
module load openmpi/1.10.2-intel12

if [[ "x$TEMPORARYDIR" == "x" ]]; then
    export TEMPORARYDIR="/home/${USER}/tmp/${JOB_ID}"
    echo "Setting TEMPORARYDIR to $TEMPORARYDIR because it was previously unspecified."
else
    echo "Using TEMPORARYDIR: $TEMPORARYDIR specified from the command line."
fi

export OUTDIR=$SGE_O_WORKDIR
export MPIDIR=/auto/soft/openmpi/1.10.2-intel12/bin/
export MPIBIN=mpirun
export CRY14P_MACH=`pwd`
export CRY14_EXEDIR="/auto/store/fpascale/test_crystal/bin/Linux-ifort_openmpi_i64_fab/std/"
export CRY14_UTILS="$CRY14_ROOT/utils14"
export CRY2K6_GRA="$CRY14_ROOT/crgra2006"
export CRY14_TEST="$CRY14_ROOT/test_cases/inputs"
export CRY14_SCRDIR=$TEMPORARYDIR
export CRY14P_MACH=`pwd`

# set up function. this isn't called/run here. It's used if the job is canceled via a signal.
cleanup_scratch() {
    echo "Deleting inside signal handler, meaning I probably either hit the walltime, or deleted the job using qdel"

    ##NOTE: IF YOU WANT TO KEEP ANY OF THE FILES FROM $TEMPORARYDIR WHEN THE JOB IS DELETED
    # BY SBATCH OR KILLED BECAUSE OF WALLTIME, USE A COMMAND LIKE THIS:
    # cp -v "$TEMPORARYDIR/${JOB_NAME}"*.mo "$SGE_O_WORKDIR"

    cd "$SGE_O_WORKDIR"
    rm -rfv "$TEMPORARYDIR"
    echo "---"
    echo "Signal handler ending time:"
    date
    exit 0
}

# Associate the function "cleanup_scratch" with the TERM signal, which is usually how jobs get killed
trap 'cleanup_scratch' TERM


# basic diagnostic output
echo "---"
echo "Beginning-of-job Diagnostic information:"
echo "---"
echo "Sun GrigEngine Queue:"
echo $PE
echo "---"
echo "Cores assigned: $NSLOTS, Nodes assigned:"
cat ${PE_HOSTFILE}
echo "---"
echo "Temporary Directory:"
echo "$TEMPORARYDIR"
echo "---"
echo "Job Source Directory:"
echo "${SGE_O_WORKDIR}"
echo "---"
echo "Current Time:"
date
echo "---"

# create temporary directory
LIST=`cat $PE_HOSTFILE | awk '{printf "%s ", $1}'`
NB=`cat $PE_HOSTFILE | awk '{printf "%s ", $2}'`
rm -f $CRY14P_MACH/nodes.par $CRY14P_MACH/machines.LINUX
cat $PE_HOSTFILE  &gt; $CRY14P_MACH/out
for i in $LIST; do
 echo $i &gt;&gt; $CRY14P_MACH/nodes.par
 echo $i &gt;&gt; $CRY14P_MACH/machines.LINUX
 for (( j=1&#160;; j&lt;$NB&#160;; j++ ))&#160;; do 
   echo $i &gt;&gt; $CRY14P_MACH/machines.LINUX
 done
 echo "Creating Temporary directory at $TEMPORARYDIR"
 #ssh $i mkdir -p $WRK
 ssh $i mkdir -pv $TEMPORARYDIR
done
echo "---"

# copy working data information from ${SGE_O_WORKDIR}/${JOB_NAME}* to $TEMPORARYDIR
echo "Copying working data information from ${SGE_O_WORKDIR}/${JOB_NAME}* to $TEMPORARYDIR"
cp -v "${SGE_O_WORKDIR}/${JOB_NAME}".d12 "$TEMPORARYDIR"/INPUT
echo "---"
if [ -f $JOB_NAME.inpxyz ]; then
 cp ${SGE_O_WORKDIR}/$JOB_NAME.inpxyz "$TEMPORARYDIR"/fort.34
 echo file ${SGE_O_WORKDIR}/$JOB_NAME.inpxyz saved as "$TEMPORARYDIR"/fort.34 &gt;&gt; $OUTDIR/$OUTFILE
fi

# changing directory to $TEMPORARYDIR
echo "Changing directory to temporary dir at $TEMPORARYDIR"
cd $TEMPORARYDIR
echo "---"


# Print environment context
echo "Print environment context"
env
echo "---"

echo "Starting CRYSTAL Run at:"
date
cat &gt;&gt; $CRY14P_MACH/out &lt;&lt; EOF
${MPIDIR}/${MPIBIN} -machinefile $CRY14P_MACH/machines.LINUX -np $NSLOTS $CRY14_EXEDIR/Pcrystal &lt; $TEMPORARYDIR/INPUT &gt;&gt; $OUTDIR/${JOB_NAME}.out
EOF
${MPIDIR}/${MPIBIN} -machinefile $CRY14P_MACH/machines.LINUX -np $NSLOTS $CRY14_EXEDIR/Pcrystal &lt; $TEMPORARYDIR/INPUT &gt;&gt; $OUTDIR/${JOB_NAME}.out  2&gt;&amp;1

date &gt;&gt; $OUTDIR/$OUTFILE
echo Contents of temporary directory in master node `hostname`: &gt;&gt; $OUTDIR/$OUTFILE
ls -l &gt;&gt; $OUTDIR/$OUTFILE

echo "Copying resulting data (${JOB_NAME}*.out) to ${SGE_O_WORKDIR}"
cp -v "$TEMPORARYDIR/${JOB_NAME}.out" "${SGE_O_WORKDIR}"
echo "---"

 if [  -f fort.9  ]; then
  cp fort.9 $OUTDIR/$JOB_NAME.f9
  echo wave function binary file $OUTDIR/$JOB_NAME.f9 &gt;&gt; $OUTDIR/$OUTFILE
 else
  echo SCF abnormal end - no wf written in fort.9 &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f fort.98 ]; then
  cp fort.98 $OUTDIR/$JOB_NAME.f98
  echo file fort.98 saved as $OUTDIR/$JOB_NAME.f98 &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f HESSOPT.DAT ]; then
  cp HESSOPT.DAT $OUTDIR/$JOB_NAME.hessopt
  echo file HESSOPT.DAT saved as $OUTDIR/$JOB_NAME.hessopt &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f HESSFREQ.DAT ]; then
  cp HESSFREQ.DAT $OUTDIR/$JOB_NAME.hessfreq
  echo file HESSFREQ.DAT saved as $OUTDIR/$JOB_NAME.hessfreq &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f OPTINFO.DAT ]; then
  cp OPTINFO.DAT $OUTDIR/$JOB_NAME.optinfo
  echo file OPTINFO.DAT saved as $OUTDIR/$JOB_NAME.optinfo &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f  SCFOUT.LOG ]; then
  cp  SCFOUT.LOG $OUTDIR/$JOB_NAME.SCFLOG
  echo file SCFOUT.LOG saved as $OUTDIR/$JOB_NAME.SCFLOG &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f FREQINFO.DAT ]; then
  cp FREQINFO.DAT $OUTDIR/$JOB_NAME.freqinfo
  echo file FREQINFO.DAT saved as $OUTDIR/$JOB_NAME.freqinfo &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f fort.32 ]; then
  cp fort.32 $OUTDIR/"$JOB_NAME".f32
  echo file fort.32 saved as $OUTDIR/$JOB_NAME.f32 &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f fort.80 ]; then
  cp fort.80 $OUTDIR/$JOB_NAME.f80
  echo file fort.80 saved as $OUTDIR/$JOB_NAME.f80 &gt;&gt; $OUTDIR/$OUTFILE
 fi
#
 if [ -f fort.33 ]; then
  cp fort.33 $OUTDIR/$JOB_NAME.xyz
  echo file fort.33 saved as $OUTDIR/$JOB_NAME.xyz &gt;&gt; $OUTDIR/$OUTFILE
 fi
 if [ -f fort.34 ]; then
  cp fort.34 $OUTDIR/$JOB_NAME.gui
  echo geometry input file fort.34 saved as $OUTDIR/$JOB_NAME.gui &gt;&gt; $OUTDIR/$OUTFILE
 fi
#
 cd $OUTDIR
 echo removing temporary directories $TMPDIR from each node &gt;&gt; $OUTDIR/$OUTFILE
 foreach n (`cat $CRY14P_MACH/nodes.par`)
  #ssh -n $n "rm -R -f $TEMPORARYDIR"
 end

echo "Changing directory back to submission directory at $SGE_O_WORKDIR"
cd "$SGE_O_WORKDIR"

echo "---"
echo "Job ending time:"
date
echo "---"
</pre>




</body></html>