<html>
<head><title>Optimisation gcc</title></head>
<body>
<h1>Optimisation gcc</h1><div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#What_are_CFLAGS_and_CXXFLAGS.3F"><span class="tocnumber">1.1</span> <span class="toctext">What are CFLAGS and CXXFLAGS?</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#How_are_they_used.3F"><span class="tocnumber">1.2</span> <span class="toctext">How are they used?</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Misconceptions"><span class="tocnumber">1.3</span> <span class="toctext">Misconceptions</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Ready.3F"><span class="tocnumber">1.4</span> <span class="toctext">Ready?</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Optimizing"><span class="tocnumber">2</span> <span class="toctext">Optimizing</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#The_basics"><span class="tocnumber">2.1</span> <span class="toctext">The basics</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#-march"><span class="tocnumber">2.2</span> <span class="toctext">-march</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#-O"><span class="tocnumber">2.3</span> <span class="toctext">-O</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#-pipe"><span class="tocnumber">2.4</span> <span class="toctext">-pipe</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#-fomit-frame-pointer"><span class="tocnumber">2.5</span> <span class="toctext">-fomit-frame-pointer</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#-msse.2C_-msse2.2C_-msse3.2C_-mmmx.2C_-m3dnow"><span class="tocnumber">2.6</span> <span class="toctext">-msse, -msse2, -msse3, -mmmx, -m3dnow</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Finding_the_CPU"><span class="tocnumber">3</span> <span class="toctext">Finding the CPU</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Find_CPU-specific_options"><span class="tocnumber">4</span> <span class="toctext">Find CPU-specific options</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#x86.2Famd64"><span class="tocnumber">5</span> <span class="toctext">x86/amd64</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#Intel"><span class="tocnumber">5.1</span> <span class="toctext">Intel</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="#Haswell"><span class="tocnumber">5.1.1</span> <span class="toctext">Haswell</span></a>
<ul>
<li class="toclevel-4 tocsection-18"><a href="#Core_i3.2Fi5.2Fi7_.26_Xeon_E3.2FE5.2FE7_.2AV2"><span class="tocnumber">5.1.1.1</span> <span class="toctext">Core i3/i5/i7 &amp; Xeon E3/E5/E7 *V2</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-19"><a href="#Ivy_Bridge"><span class="tocnumber">5.1.2</span> <span class="toctext">Ivy Bridge</span></a>
<ul>
<li class="toclevel-4 tocsection-20"><a href="#Core_i3.2Fi5.2Fi7_.26_Xeon_E3.2FE5.2FE7_.2AV1"><span class="tocnumber">5.1.2.1</span> <span class="toctext">Core i3/i5/i7 &amp; Xeon E3/E5/E7 *V1</span></a></li>
<li class="toclevel-4 tocsection-21"><a href="#Pentium"><span class="tocnumber">5.1.2.2</span> <span class="toctext">Pentium</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-22"><a href="#Sandy_Bridge"><span class="tocnumber">5.1.3</span> <span class="toctext">Sandy Bridge</span></a>
<ul>
<li class="toclevel-4 tocsection-23"><a href="#Core_i3.2Fi5.2Fi7_.26_Xeon_E3.2FE5.2FE7"><span class="tocnumber">5.1.3.1</span> <span class="toctext">Core i3/i5/i7 &amp; Xeon E3/E5/E7</span></a></li>
<li class="toclevel-4 tocsection-24"><a href="#Pentium_2"><span class="tocnumber">5.1.3.2</span> <span class="toctext">Pentium</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-25"><a href="#Nehalem.2FWestmere"><span class="tocnumber">5.1.4</span> <span class="toctext">Nehalem/Westmere</span></a>
<ul>
<li class="toclevel-4 tocsection-26"><a href="#Core_i3.2Fi5.2Fi7"><span class="tocnumber">5.1.4.1</span> <span class="toctext">Core i3/i5/i7</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-27"><a href="#Intel_Core"><span class="tocnumber">5.1.5</span> <span class="toctext">Intel Core</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Older_microarchitecture"><span class="tocnumber">5.1.6</span> <span class="toctext">Older microarchitecture</span></a>
<ul>
<li class="toclevel-4 tocsection-29"><a href="#Pentium_M_.28Dothan.29"><span class="tocnumber">5.1.6.1</span> <span class="toctext">Pentium M (Dothan)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-30"><a href="#AMD"><span class="tocnumber">5.2</span> <span class="toctext">AMD</span></a>
<ul>
<li class="toclevel-3 tocsection-31"><a href="#A4.2FA6.2FA8-XXXX_.2F_XXXXM"><span class="tocnumber">5.2.1</span> <span class="toctext">A4/A6/A8-XXXX / XXXXM</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#FX-XXXX"><span class="tocnumber">5.2.2</span> <span class="toctext">FX-XXXX</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Geode_LX"><span class="tocnumber">5.2.3</span> <span class="toctext">Geode  LX</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-34"><a href="#arm"><span class="tocnumber">6</span> <span class="toctext">arm</span></a>
<ul>
<li class="toclevel-2 tocsection-35"><a href="#Cortex-A"><span class="tocnumber">6.1</span> <span class="toctext">Cortex-A</span></a>
<ul>
<li class="toclevel-3 tocsection-36"><a href="#ARMv7-A.2FCortex-A9_MPCore"><span class="tocnumber">6.1.1</span> <span class="toctext">ARMv7-A/Cortex-A9 MPCore</span></a>
<ul>
<li class="toclevel-4 tocsection-37"><a href="#with_optional_VFPv3_FPU"><span class="tocnumber">6.1.1.1</span> <span class="toctext">with optional VFPv3 FPU</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-38"><a href="#ARM11"><span class="tocnumber">6.2</span> <span class="toctext">ARM11</span></a>
<ul>
<li class="toclevel-3 tocsection-39"><a href="#ARMv6.2FARM1176JZF-S"><span class="tocnumber">6.2.1</span> <span class="toctext">ARMv6/ARM1176JZF-S</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="#ARMv6.2FARM1136JF-S"><span class="tocnumber">6.2.2</span> <span class="toctext">ARMv6/ARM1136JF-S</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-41"><a href="#ppc.2Fppc64"><span class="tocnumber">7</span> <span class="toctext">ppc/ppc64</span></a>
<ul>
<li class="toclevel-2 tocsection-42"><a href="#POWER8"><span class="tocnumber">7.1</span> <span class="toctext">POWER8</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="#Cell"><span class="tocnumber">7.2</span> <span class="toctext">Cell</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="#G4"><span class="tocnumber">7.3</span> <span class="toctext">G4</span></a>
<ul>
<li class="toclevel-3 tocsection-45"><a href="#PPC_7447A"><span class="tocnumber">7.3.1</span> <span class="toctext">PPC 7447A</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-46"><a href="#G3_.28PPC_7XX.29"><span class="tocnumber">7.4</span> <span class="toctext">G3 (PPC 7XX)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="#m68k"><span class="tocnumber">8</span> <span class="toctext">m68k</span></a></li>
<li class="toclevel-1 tocsection-48"><a href="#Not_in_the_list.3F"><span class="tocnumber">9</span> <span class="toctext">Not in the list?</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Introduction">Introduction</span></h2>
<h3><span class="mw-headline" id="What_are_CFLAGS_and_CXXFLAGS.3F">What are CFLAGS and CXXFLAGS?</span></h3>
<p><var>CFLAGS</var> and <var>CXXFLAGS</var> are environment variables 
that are used to tell the GNU Compiler Collection (GCC) what kinds of 
switches to use when compiling source code. The <var>CFLAGS</var> variable is used for compiling code written in C, while the <var>CXXFLAGS</var> variable is for code written in C++. 
</p><p>They can be used to decrease the amount of debug messages for a 
program, increase error warning levels, and, of course, to optimize the 
code produced. The GCC manual maintains a complete list of available options and their purposes.
</p>
<h3><span class="mw-headline" id="How_are_they_used.3F">How are they used?</span></h3>
<p><var>CFLAGS</var> and <var>CXXFLAGS</var> can be used in two ways. First, they can be used per-program with Makefiles generated by the automake program. 
</p><p>However, this should not be done when installing packages found 
in the Portage tree. Instead, for Gentoo-based machines, set the <var>CFLAGS</var> and <var>CXXFLAGS</var> variables in /etc/portage/make.conf This way all packages will be compiled using the options specified in make.conf
</p><p>CODE <strong>Setting CFLAGS in /etc/portage/make.conf</strong>
</p><p><strong> Important</strong>
While it is possible to have multiple lines in <b>USE</b> flags, having multiple lines in <var>CFLAGS</var> can and <i>will</i> result in problems with programs such as cmake. Make sure the CFLAGS declaration is on a single line, with as little whitespace as possible to avoid issues. See bug #500034 as an example.
</p><p>As seen in the example above the <var>CXXFLAGS</var> variable is set to use all the options present in <var>CFLAGS</var>. Most every system should be configured in this manner; additional options for <var>CXXFLAGS</var> are <i>extremely rare</i> in common use cases.
</p>
<h3><span class="mw-headline" id="Misconceptions">Misconceptions</span></h3>
<p>While <var>CFLAGS</var> and <var>CXXFLAGS</var> can be very effective
 means of getting source code to produce smaller and/or faster binaries,
 they can also impair the function of the code, bloat its size, slow 
down its execution time. Setting them incorrectly can even cause 
compilation failures! 
</p><p><var>CFLAGS</var> are not a magic bullet; they will not 
automatically make the system run faster or reduce the size of binaries 
on the disk. Adding too many flags in an attempt to optimize (or "rice")
 the system is a sure recipe for failure. The point of diminishing 
returns is reached rather quickly when dealing with <var>CFLAGS</var>. 
</p><p>Despite the boasts and brags found on the internet, aggressive <var>CFLAGS</var> and <var>CXXFLAGS</var> are far more likely to harm binaries than to do any good. Keep in mind the flags are designed to be used at <i>specific</i> places for <i>specific</i> purposes. Few flags work as intended globally.
</p>
<h3><span class="mw-headline" id="Ready.3F">Ready?</span></h3>
<p>Being aware of the risks involved, take a look at some sane, safe 
optimizations. These will hold in good stead and will be endearing to 
developers the next time a problem  is reported on Bugzilla. (Developers will usually request the user to recompile a package with minimal <var>CFLAGS</var> to see if the problem persists. Remember: aggressive flags can ruin code!) 
</p>
<h2><span class="mw-headline" id="Optimizing">Optimizing</span></h2>
<h3><span class="mw-headline" id="The_basics">The basics</span></h3>
<p>The goal behind <var>CFLAGS</var> and <var>CXXFLAGS</var> is to 
create code tailor-made to your system; it should function perfectly 
while being lean and fast, if possible. Sometimes these conditions are 
mutually exclusive, so this guide will stick to combinations known to 
work well. Ideally, they are the best available for any CPU 
architecture. For informational purposes, aggressive flag use will be 
covered later. Not every option listed on the GCC manual (there are 
hundreds) will be discussed, but basic, most common flags will be 
reviewed. 
</p><p><strong> Note</strong>
When unaware of what a flag does refer to the relevant chapter of the GCC manual. If still stumped after viewing the manual, try a search engine or check out the GCC mailing lists.
</p>
<h3><span class="mw-headline" id="-march">-march</span></h3>
<p>The first and most important option is <code>-march</code>. This tells the compiler what code it should produce for the system's processor architecture (or <i>arch</i>);
 it tells GCC that it should produce code for a certain kind of CPU. 
Different CPUs have different capabilities, support different 
instruction sets, and have different ways of executing code. The <code>-march</code>
 flag will instruct the compiler to produce specific code for the 
system's CPU, with all its capabilities, features, instruction sets, 
quirks, and so on. 
</p><p>Even though the <code>CHOST</code> variable in /etc/portage/make.conf specifies the general architecture used, <code>-march</code>
 should still be used so that programs can be optimized for the system 
specific processor. x86 and x86-64 CPUs (among others) should make use 
of the <code>-march</code> flag. 
</p><p>What kind of CPU does the system have? To find out, run the following command: 
</p><p><code>user $cat /proc/cpuinfo</code>
</p><p>To get more details, including <code>march</code> and <code>mtune</code> values, use:
</p><p><code>user $gcc -c -Q -march=native --help=target</code>
</p><p>Now lets see <code>-march</code> in action. This example is for an older Pentium III chip: 
</p><p>FILE <strong><code>/etc/portage/make.conf</code>Pentium III example</strong>
</p><p>Here's another one for a 64-bit AMD CPU: 
</p><p>FILE <strong><code>/etc/portage/make.conf</code>AMD64 example</strong>
</p><p>If the type of CPU is undetermined, or if the user does not know what setting to choose, it is possible use the <code>-march=native</code> setting. When this flag is used, GCC will attempt to detect the processor and automatically set appropriate flags for it. <b>However, this should not be used when intending to compile packages for different CPUs!</b> 
</p><p><strong> Warning</strong>
Do <b>not</b> use <code>-march=native</code> or <code>-mtune=native</code> in the <var>CFLAGS</var> or <var>CXXFLAGS</var> variables of make.conf when compiling with distcc.
</p><p>If compiling packages on one computer in order to run them on a 
different computer (such as when using a fast computer to build for an 
older, slower machine), then <i>do not</i> use <code>-march=native</code>. "Native" means that the code produced will run <i>only</i> on that type of CPU. The applications built with <code>-march=native</code> on an AMD Athlon 64 CPU will <i><b>not</b></i> be able to run on an old VIA C3 CPU. 
</p><p>Also available are the <code>-mtune</code> and <code>-mcpu</code> flags. These flags are normally only used when there is no available <code>-march</code> option; certain processor architectures may require <code>-mtune</code> or even <code>-mcpu</code>. Unfortunately, GCC's behavior isn't very consistent with how each flag behaves from one architecture to the next. 
</p><p>On x86 and x86-64 CPUs, <code>-march</code> will generate code 
specifically for that CPU using its available instruction sets and the 
correct ABI; it will have no backwards compatibility for older/different
 CPUs. Consider using <code>-mtune</code> when generating code for older CPUs such as i386 and i486. <code>-mtune</code> produces more generic code than <code>-march</code>; though it will tune code for a certain CPU, it does not take into account available instruction sets and ABI. Do not use <code>-mcpu</code> on x86 or x86-64 systems, as it is deprecated for those arches. 
</p><p>Only non-x86/x86-64 CPUs (such as Sparc, Alpha, and PowerPC) may require <code>-mtune</code> or <code>-mcpu</code> instead of <code>-march</code>. On these architectures, <code>-mtune</code> / <code>-mcpu</code> will sometimes behave just like <code>-march</code>
 (on x86/x86-64) but with a different flag name. Again, GCC's behavior 
and flag naming is not consistent across architectures, so be sure to 
check the GCC manual to determine which one should be used. 
</p><p><strong> Note</strong>
For more suggested <code>-march</code> / <code>-mtune</code> / <code>-mcpu</code> settings, please read chapter 5 of the appropriate Gentoo Installation Handbook for the arch. Also, read the GCC manual's list of architecture-specific options, as well as more detailed explanations about the differences between <code>-march</code>, <code>-mcpu</code>, and <code>-mtune</code>.
</p>
<h3><span class="mw-headline" id="-O">-O</span></h3>
<p>Next up is the <code>-O</code> variable. This variable controls the 
overall level of optimization. Changing this value will make the code 
compilation take more time and will use much more memory, especially as 
the level of optimization is increased. 
</p><p>There are seven <code>-O</code> settings: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Og</code>, and <code>-Ofast</code>. Only use one of them in /etc/portage/make.conf
</p><p>With the exception of <code>-O0</code>, the <code>-O</code> settings each activate several additional flags, so be sure to read the GCC manual's chapter on optimization options to learn which flags are activated at each <code>-O</code> level, as well as some explanations as to what they do. 
</p><p>Let us examine each optimization level: 
</p>
<ul><li>  <code>-O0</code>: This level (that is the letter "O" followed by a zero) turns off optimization entirely and is the default if no <code>-O</code> level is specified in <var>CFLAGS</var> or <var>CXXFLAGS</var>.  This reduces compilation time and can improve debugging info, but some  applications will not work properly without optimization enabled. This  option is not recommended except for debugging purposes.</li></ul>
<ul><li>  <code>-O1</code>: the most basic optimization level. The  compiler will try to produce faster, smaller code without taking much  compilation time. It is basic, but it should get the job done all the  time.</li></ul>
<ul><li>  <code>-O2</code>: A step up from <code>-O1</code>. The <i>recommended</i> level of optimization unless the system has special needs. <code>-O2</code> will activate a few more flags in addition to the ones activated by <code>-O1</code>. With <code>-O2</code>,  the compiler will attempt to increase code performance without  compromising on size, and without taking too much compilation time.</li></ul>
<ul><li>  <code>-O3</code>: the highest level of optimization possible.  It enables optimizations that are expensive in terms of compile time and  memory usage.  Compiling with <code>-O3</code> is not a guaranteed way  to improve performance, and in fact, in many cases, can slow down a  system due to larger binaries and increased memory usage. <code>-O3</code> is also known to break several packages. Using <code>-O3</code> is not recommended.</li></ul>
<ul><li>  <code>-Os</code>: optimizes code for size. It activates all <code>-O2</code>  options that do not increase the size of the generated code. It can be  useful for machines that have extremely limited disk storage space  and/or CPUs with small cache sizes.</li></ul>
<ul><li>  <code>-Og</code>: In GCC 4.8, a new general optimization level, <code>-Og</code>,  has been introduced. It addresses the need for fast compilation and a  superior debugging experience while providing a reasonable level of  runtime performance. Overall experience for development should be better  than the default optimization level <code>-O0</code>.  Note that <code>-Og</code> does not imply <code>-g</code>, it simply disables optimizations that may interfere with debugging.</li></ul>
<ul><li>  <code>-Ofast</code>: New in GCC 4.7, consists of <code>-O3</code> plus <code>-ffast-math</code>, <code>-fno-protect-parens</code>, and <code>-fstack-arrays</code>. This option breaks strict standards compliance, and is not recommended for use.</li></ul>
<p>As previously mentioned, <code>-O2</code> is the recommended optimization level. If package compilation fails and while not using <code>-O2</code>, try rebuilding with that option. As a fallback option, try setting the <var>CFLAGS</var> and <var>CXXFLAGS</var> to a lower optimization level, such as <code>-O1</code> or even <code>-O0 -g2 -ggdb</code> (for error reporting and checking for possible problems).
</p>
<h3><span class="mw-headline" id="-pipe">-pipe</span></h3>
<p>A common flag is <code>-pipe</code>. This flag has no effect on the generated code, but it makes the compilation process <i>faster</i>.
 It tells the compiler to use pipes instead of temporary files during 
the different stages of compilation, which uses more memory. On systems 
with low memory, GCC might get killed. In those cases do not use this 
flag. 
</p>
<h3><span class="mw-headline" id="-fomit-frame-pointer">-fomit-frame-pointer</span></h3>
<p>This is a very common flag designed to reduce generated code size. It is turned on at all levels of <code>-O</code> (except <code>-O0</code>)
 on architectures where doing so does not interfere with debugging (such
 as x86-64), but it may need to activated. In that case add it to the 
flags. Though the GCC manual does not specify all architectures, it is 
turned on by using the <code>-O</code> option. It's still necessary to explicitly enable the <code>-fomit-frame-pointer</code> option, to activate it on x86-32 with GCC up to version 4.6, or when using <code>-Os</code> on x86-32 with any version of GCC. However, using <code>-fomit-frame-pointer</code> will make debugging hard or impossible. 
</p><p>In particular, it makes troubleshooting applications written in 
Java much harder, though Java is not the only code affected by using 
this flag. So while the flag can help, it also makes debugging harder; 
backtraces in particular will be useless. When not doing software 
debugging and no other debugging-related <var>CFLAGS</var> such as <code>-ggdb</code> have been used, then try using <code>-fomit-frame-pointer</code>. 
</p><p><strong> Important</strong>
Do <i>not</i> combine <code>-fomit-frame-pointer</code> with the similar flag <code>-momit-leaf-frame-pointer</code>. Using the latter flag is discouraged, as <code>-fomit-frame-pointer</code> already does the job properly. Furthermore, <code>-momit-leaf-frame-pointer</code> has been shown to negatively impact code performance.
</p>
<h3><span class="mw-headline" id="-msse.2C_-msse2.2C_-msse3.2C_-mmmx.2C_-m3dnow">-msse, -msse2, -msse3, -mmmx, -m3dnow</span></h3>
<p>These flags enable the Streaming SIMD Extentions (SSE), SSE2, SSE3, MMX, and 3DNow!
 instruction sets for x86 and x86-64 architectures. These are useful 
primarily in multimedia, gaming, and other floating point-intensive 
computing tasks, though they also contain several other mathematical 
enhancements. These instruction sets are found in more modern CPUs. 
</p><p><strong> Important</strong>
Be sure to see if the CPU supports these instruction sets by running <kbd>cat /proc/cpuinfo</kbd>. The output will include any supported additional instruction sets. Note that <b>pni</b> is just a different name for SSE3.
</p><p>Normally none of these flags need to be added to /etc/portage/make.conf, as long as the system is using the correct <code>-march</code> (for example, <code>-march=nocona</code> implies <code>-msse3</code>). Some notable exceptions are newer VIA and AMD64 CPUs that support instructions not implied by <code>-march</code> (such as SSE3). For CPUs like these additional flags will need to be enabled where appropriate after checking /proc/cpuinfo. 
</p><p><strong> Note</strong>
Check the list of x86 and x86-64-specific flags
 to see which of these instruction sets are activated by the proper CPU 
type flag. If an instruction is listed, then it does not need to be 
separately specified; it will be turned on by using the proper <code>-march</code> setting.
</p>
<h2><span class="mw-headline" id="Finding_the_CPU">Finding the CPU</span></h2>
<p>To identify the model of the CPU, take a look inside /proc/cpuinfo for the "cpu family" and "model" numbers like so:
</p><p><code>user $grep -m1 -A3 "vendor_id" /proc/cpuinfo</code>
</p><p>Once this information is found match the CPU to one listed on this page in order to find out the suggested "safe" <var>CFLAGS</var>.
</p><p>Below is a list of CFLAGS
 which are to be considered "safe" for the given processors. These are 
the settings that should be used, especially when unsure which CFLAGS 
the processor needs.
</p>
<h2><span class="mw-headline" id="Find_CPU-specific_options">Find CPU-specific options</span></h2>
<p>At first, create two files and set language to English to get sed working:
</p><p><code>user $touch native.cc march.cc
</code>
</p><p><code>user $LANG="en"
</code>
</p><p>Compile the first file:
</p><p><code>user $gcc -fverbose-asm -march=native native.cc -S
</code>
</p><p>Get march, which gcc will choose:
</p><p><code>user $grep march native.s
</code>
</p><p>Options passed: <code>-D_GNU_SOURCE native.cc -march=core-avx-i -mcx16 -msahf</code>
</p><p>Now compile a second file:
</p><p><code>user $gcc -fverbose-asm -march=core-avx-i march.cc -S
</code>
</p><p>Now clean the *.s files for an easy comparisons:
</p><p><code>user $sed -i 1,/options\ enabled/d march.s
</code>
</p><p><code>user $sed -i 1,/options\ enabled/d native.s
</code>
</p><p><b>When you not set LANG on an localized system, you have now empty files.</b>
</p><p>Compare both *.s files:
</p><p><code>user $diff march.s native.s
</code>
</p><p>Output empty? You found your -march=, use it. In other cases:
</p>
<pre>20,25c20,23
&lt; # -maccumulate-outgoing-args -maes -malign-stringops -mavx
&lt; # -mavx256-split-unaligned-load -mavx256-split-unaligned-store -mcx16
&lt; # -mf16c -mfancy-math-387 -mfp-ret-in-387 -mfsgsbase -mfxsr -mglibc
&lt; # -mieee-fp -mlong-double-80 -mmmx -mpclmul -mpopcnt -mpush-args -mrdrnd
&lt; # -mred-zone -msahf -msse -msse2 -msse3 -msse4 -msse4.1 -msse4.2 -mssse3
&lt; # -mtls-direct-seg-refs -mxsave -mxsaveopt
---
&gt; # -maccumulate-outgoing-args -malign-stringops -mcx16 -mfancy-math-387
&gt; # -mfp-ret-in-387 -mfsgsbase -mfxsr -mglibc -mieee-fp -mlong-double-80
&gt; # -mmmx -mpclmul -mpopcnt -mpush-args -mred-zone -msahf -msse -msse2 -msse3
&gt; # -msse4 -msse4.1 -msse4.2 -mssse3 -mtls-direct-seg-refs
</pre>
<p>Now guess, which switches -march=core-avx-i enable and -march=native not: <i>-maes -mavx</i> and some more. Now we build march.cc again with this two switches disabled:
</p>
<pre>gcc -fverbose-asm -march=core-avx-i -mno-aes -mno-avx march.cc -S
sed -i 1,/options\ enabled/d march.s
diff march.s native.s

&lt; # -mmmx -mpclmul -mpopcnt -mpush-args -mrdrnd -mred-zone -msahf -msse
&lt; # -msse2 -msse3 -msse4 -msse4.1 -msse4.2 -mssse3 -mtls-direct-seg-refs
---
&gt; # -mmmx -mpclmul -mpopcnt -mpush-args -mred-zone -msahf -msse -msse2 -msse3
&gt; # -msse4 -msse4.1 -msse4.2 -mssse3 -mtls-direct-seg-refs
</pre>
<p>One switch we need to disable too: -mrdrnd
</p><p>Finally set CFLAGS:
</p><p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h2><span class="mw-headline" id="x86.2Famd64">x86/amd64</span></h2>
<h3><span class="mw-headline" id="Intel">Intel</span></h3>
<h4><span class="mw-headline" id="Haswell">Haswell</span></h4>
<h5><span class="mw-headline" id="Core_i3.2Fi5.2Fi7_.26_Xeon_E3.2FE5.2FE7_.2AV2">Core i3/i5/i7 &amp; Xeon E3/E5/E7 *V2</span></h5>
<pre>vendor_id	: GenuineIntel
cpu family	: 6
model		: 60
model name	: Intel(R) Xeon(R) CPU E3-1271 v3 @ 3.60GHz
…
model           : 60
model name      : Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p><p><strong> Note</strong>
<i>core-avx2</i> march support was introduced with GCC 4.7. If you have an earlier version of GCC, use <i>-march=native</i> or find cpu-specific options manually.
</p>
<h4><span class="mw-headline" id="Ivy_Bridge">Ivy Bridge</span></h4>
<h5><span class="mw-headline" id="Core_i3.2Fi5.2Fi7_.26_Xeon_E3.2FE5.2FE7_.2AV1">Core i3/i5/i7 &amp; Xeon E3/E5/E7 *V1</span></h5>
<pre>vendor_id       : GenuineIntel
cpu family      : 6
model           : 58
model name      : Intel(R) Core(TM) i7-3610QM CPU @ 2.30GHz 
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h5><span class="mw-headline" id="Pentium">Pentium</span></h5>
<pre>vendor_id	: GenuineIntel
cpu family	: 6
model		: 58
model name	: Intel(R) Pentium(R) CPU G2020 @ 2.90GHz
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h4><span class="mw-headline" id="Sandy_Bridge">Sandy Bridge</span></h4>
<h5><span class="mw-headline" id="Core_i3.2Fi5.2Fi7_.26_Xeon_E3.2FE5.2FE7">Core i3/i5/i7 &amp; Xeon E3/E5/E7</span></h5>
<pre>vendor_id	: GenuineIntel
cpu family	: 6
…
model		: 42
model name	: Intel(R) Core(TM) i5-2400 CPU @ 3.10GHz
…
model		: 45
model name	: Intel(R) Core(TM) i7-3930K CPU @ 3.20GHz
… 
model		: 42
model name	: Intel(R) Xeon(R) CPU E31245 @ 3.30GHz
… 
model           : 45
model name      : Intel(R) Xeon(R) CPU E5-2407 0 @ 2.20GHz
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h5><span class="mw-headline" id="Pentium_2">Pentium</span></h5>
<pre>vendor_id	: GenuineIntel
cpu family	: 6
model		: 42
model name	: Intel(R) Pentium(R) CPU B960 @ 2.20GHz
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h4><span class="mw-headline" id="Nehalem.2FWestmere">Nehalem/Westmere</span></h4>
<h5><span class="mw-headline" id="Core_i3.2Fi5.2Fi7">Core i3/i5/i7</span></h5>
<pre>vendor_id	: GenuineIntel
cpu family	: 6
model		: 42
model name	: Intel(R) Core(TM) i5-2400 CPU @ 3.10GHz
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h4><span class="mw-headline" id="Intel_Core">Intel Core</span></h4>
<pre>vendor_id       : GenuineIntel
cpu family      : 6
…
model		: 15
model name	: Intel(R) Core(TM)2 Duo CPU     T7500  @ 2.20GHz
…
model           : 15
model name      : Intel(R) Xeon(R) CPU            3040  @ 1.86GHz
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h4><span class="mw-headline" id="Older_microarchitecture">Older microarchitecture</span></h4>
<h5><span class="mw-headline" id="Pentium_M_.28Dothan.29">Pentium M (Dothan)</span></h5>
<pre>vendor_id	: GenuineIntel
cpu family	: 6
model		: 13
model name	: Intel(R) Pentium(R) M processor 2.13GHz
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h3><span class="mw-headline" id="AMD">AMD</span></h3>
<h4><span class="mw-headline" id="A4.2FA6.2FA8-XXXX_.2F_XXXXM">A4/A6/A8-XXXX / XXXXM</span></h4>
<pre>vendor_id	: AuthenticAMD
cpu family	: 18
model		: 1
model name	: AMD A8-3500M APU with Radeon(tm) HD Graphics
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h4><span class="mw-headline" id="FX-XXXX">FX-XXXX</span></h4>
<pre>vendor_id	: AuthenticAMD
cpu family	: 21
model		: 1
model name	: AMD FX(tm)-8150 Eight-Core Processor
</pre>
<p>Make sure and check the number listed by <code>model</code> on your system, the -march flag should be bdverX where X is the model number.
</p><p>Due to the FPU design of the Bulldozer architecture, -mprefer-avx128 gives better FPU preformance at the cost of precision.
</p><p>The -mvzeroupper switch will give much less of a preformance 
penalty when using both SSE and AVX, it isn't much of a performance 
boost for most apps, but can provide a significant improvement when used
 with stuff like media-video/ffmpeg, net-misc/bfgminer or some apps in 
games-emulation that have some sections coded in assembly.
</p><p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h4><span class="mw-headline" id="Geode_LX">Geode  LX</span></h4>
<pre>vendor_id	: AuthenticAMD
cpu family	: 5
model		: 10
model name	: Geode(TM) Integrated Processor by AMD PCS
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h2><span class="mw-headline" id="arm">arm</span></h2>
<p><strong> Note</strong>
To identify the respective ARM core of the SoC on your board, List of ARM microarchitectures  and List of applications of ARM cores on Wikipedia may help.
</p>
<h3><span class="mw-headline" id="Cortex-A">Cortex-A</span></h3>
<h4><span class="mw-headline" id="ARMv7-A.2FCortex-A9_MPCore">ARMv7-A/Cortex-A9 MPCore</span></h4>
<h5><span class="mw-headline" id="with_optional_VFPv3_FPU">with optional VFPv3 FPU</span></h5>
<pre>processor       : 0
model name      : ARMv7 Processor rev 0 (v7l)
BogoMIPS        : 2.00
Features        : half thumb fastmult vfp edsp vfpv3 vfpv3d16 tls 
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x1
CPU part        : 0xc09
CPU revision    : 0

processor       : 1
model name      : ARMv7 Processor rev 0 (v7l)
BogoMIPS        : 2.00
Features        : half thumb fastmult vfp edsp vfpv3 vfpv3d16 tls 
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x1
CPU part        : 0xc09
CPU revision    : 0

Hardware        : NVIDIA Tegra SoC (Flattened Device Tree)
Revision        : 0000
Serial          : 0000000000000000
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p><p><strong> Note</strong>
This
 ARM core (equipped with the optional vfpv3d16 FPU but missing the NEON 
extension) is used in the Toshiba AC100/Dynabook AZ/Compal Paz00 Board.
</p>
<h3><span class="mw-headline" id="ARM11">ARM11</span></h3>
<h4><span class="mw-headline" id="ARMv6.2FARM1176JZF-S">ARMv6/ARM1176JZF-S</span></h4>
<h4><span class="mw-headline" id="ARMv6.2FARM1136JF-S">ARMv6/ARM1136JF-S</span></h4>
<pre>Processor       : ARMv6-compatible processor rev 5 (v6l)
BogoMIPS        : 791.34
Features        : swp half thumb fastmult vfp edsp java 
CPU implementer : 0x41
CPU architecture: 6TEJ
CPU variant     : 0x1
CPU part        : 0xb36
CPU revision    : 5

Hardware        : IMAPX200
Revision        : 0000
Serial          : 0000000000000000
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h2><span class="mw-headline" id="ppc.2Fppc64">ppc/ppc64</span></h2>
<p><strong> Note</strong>
<code>-march=native</code> almost never works on PowerPC.
</p>
<h3><span class="mw-headline" id="POWER8">POWER8</span></h3>
<pre>processor       : 0
cpu             : POWER8E (raw), altivec supported
clock           : 3026.000000MHz
revision        : 2.1 (pvr 004b 0201)

timebase        : 512000000
platform        : pSeries
model           : IBM pSeries (emulated by qemu)
machine         : CHRP IBM pSeries (emulated by qemu)
</pre>
<p><strong> Note</strong>
Currently Gentoo does not support POWER8, but safe CFLAGS for it would look like the following.
</p><p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h3><span class="mw-headline" id="Cell">Cell</span></h3>
<pre>processor	: 0
cpu		: Cell Broadband Engine, altivec supported
clock		: 3192.000000MHz
revision	: 5.1 (pvr 0070 0501)

processor	: 1
cpu		: Cell Broadband Engine, altivec supported
clock		: 3192.000000MHz
revision	: 5.1 (pvr 0070 0501)

timebase	: 79800000
platform	: PS3
model		: SonyPS3
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p><p><strong> Note</strong>
GCC's
 -mspe and -mabi=spe options are not targetting PS3 systems and IBM 
Cell. Instead, those options are dedicated to IBM e500. More info: https://lists.debian.org/debian-devel/2011/06/msg00592.html https://wiki.debian.org/PowerPCSPEPort
</p>
<h3><span class="mw-headline" id="G4">G4</span></h3>
<h4><span class="mw-headline" id="PPC_7447A">PPC 7447A</span></h4>
<pre>processor	: 0
cpu		: 7447A, altivec supported
clock		: 1666.666000MHz
revision	: 1.5 (pvr 8003 0105)
bogomips	: 33.28
timebase	: 8320000
platform	: PowerMac
model		: PowerBook5,9
machine		: PowerBook5,9
motherboard	: PowerBook5,9 MacRISC3 Power Macintosh 
detected as	: 287 (PowerBook G4 17")
pmac flags	: 00000018
L2 cache	: 512K unified
pmac-generation	: NewWorld
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h3><span class="mw-headline" id="G3_.28PPC_7XX.29">G3 (PPC 7XX)</span></h3>
<pre>processor       : 0
cpu             : 740/750
clock           : 400.000000MHz
revision        : 131.0 (pvr 0008 8300)
bogomips        : 49.93
timebase        : 24966218
platform        : PowerMac
model           : PowerBook3,1
machine         : PowerBook3,1
motherboard     : PowerBook3,1 MacRISC2 MacRISC Power Macintosh
detected as     : 70 (PowerBook Pismo)
pmac flags      : 0000001f
L2 cache        : 1024K unified
pmac-generation : NewWorld
</pre>
<p>FILE <strong><code>/etc/portage/make.conf</code></strong>
</p>
<h2><span class="mw-headline" id="m68k">m68k</span></h2>
<h2><span class="mw-headline" id="Not_in_the_list.3F">Not in the list?</span></h2>
<p>Try the following command to see if you will see something useful.
</p><p>You will get something like below...
</p><p>Notice the -march reply?
</p><p>Get this info from Distcc  Wiki Page<sup>[1]</sup>
</p><p><code>root #gcc -march=native -E -v - &lt;/dev/null 2&gt;&amp;1 | grep cc1</code>
</p>
<pre> /mnt/livecd/usr/x86_64-pc-linux-gnu/gcc-bin/4.7.3/../../../libexec/gcc/x86_64-pc-linux-gnu/4.7.3/cc1 -E -quiet -v -iprefix /mnt/livecd/usr/x86_64-pc-linux-gnu/gcc-bin/4.7.3/../../../lib/gcc/x86_64-pc-linux-gnu/4.7.3/ - 
-march=corei7-avx -mcx16 -msahf -mno-movbe -maes -mpclmul -mpopcnt -mno-abm -mno-lwp -mno-fma -mno-fma4 -mno-xop -mno-bmi -mno-bmi2 -mno-tbm -mavx -mno-avx2 -msse4.2 -msse4.1 -mno-lzcnt -mno-rdrnd -mno-f16c -mno-fsgsbase --param l1-cache-size=32 --param l1-cache-line-size=64 --param l2-cache-size=10240 -mtune=corei7-avx
</pre>



</body></html>